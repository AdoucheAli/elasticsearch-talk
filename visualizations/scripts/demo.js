// Generated by CoffeeScript 1.7.1
(function() {
  var Aggregation, DateHistogramAggregation, HistogramAggregation, TermsAggregation, buildAggregationBody, flattenAggregationResults,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Aggregation = (function() {
    Aggregation.prototype.dimension = null;

    Aggregation.prototype.group = null;

    function Aggregation(opts) {
      this.reduceSumFunction = __bind(this.reduceSumFunction, this);
      this.dimensionFunction = __bind(this.dimensionFunction, this);
      _.assign(this, opts);
      if (!this.name) {
        throw new Error('Name is not defined');
      }
    }

    Aggregation.prototype.chartPostSetup = function() {};

    Aggregation.prototype.bucketKey = function(bucket) {
      return bucket.key;
    };

    Aggregation.prototype.bucketCount = function(bucket) {
      return bucket.doc_count;
    };

    Aggregation.prototype.mapBucket = function(bucket) {
      return {
        key: this.bucketKey(bucket),
        count: this.bucketCount(bucket)
      };
    };

    Aggregation.prototype.dimensionFunction = function(d) {
      return d[this.name];
    };

    Aggregation.prototype.reduceSumFunction = function(d) {
      return d.count;
    };

    Aggregation.prototype.applyToCrossfilter = function(ndx) {
      this.dimension = ndx.dimension(this.dimensionFunction);
      return this.group = this.dimension.group().reduceSum(this.reduceSumFunction);
    };

    return Aggregation;

  })();

  DateHistogramAggregation = (function(_super) {
    __extends(DateHistogramAggregation, _super);

    function DateHistogramAggregation(opts) {
      DateHistogramAggregation.__super__.constructor.call(this, opts);
      this.interval = this.interval || 'day';
      if (!this.field) {
        throw new Error("Date histogram field for '" + this.name + "' is not defined");
      }
    }

    DateHistogramAggregation.prototype.aggregator = function() {
      return {
        date_histogram: {
          field: this.field,
          interval: this.interval
        }
      };
    };

    DateHistogramAggregation.prototype.bucketKey = function(bucket) {
      return new Date(bucket.key_as_string);
    };

    return DateHistogramAggregation;

  })(Aggregation);

  HistogramAggregation = (function(_super) {
    __extends(HistogramAggregation, _super);

    function HistogramAggregation(opts) {
      HistogramAggregation.__super__.constructor.call(this, opts);
      this.interval = this.interval || 1;
      if (!this.field) {
        throw new Error("Histogram field for '" + this.name + "' is not defined");
      }
    }

    HistogramAggregation.prototype.aggregator = function() {
      return {
        histogram: {
          field: this.field,
          interval: this.interval
        }
      };
    };

    return HistogramAggregation;

  })(Aggregation);

  TermsAggregation = (function(_super) {
    __extends(TermsAggregation, _super);

    function TermsAggregation(opts) {
      TermsAggregation.__super__.constructor.call(this, opts);
      if (!this.field) {
        throw new Error("Terms field for '" + this.name + "' is not defined");
      }
    }

    TermsAggregation.prototype.aggregator = function() {
      return {
        terms: {
          field: this.field
        }
      };
    };

    return TermsAggregation;

  })(Aggregation);

  window.angular.module('app', ['angularDc']);

  buildAggregationBody = function(aggregations) {
    var body, first, rest;
    body = {};
    first = _.first(aggregations);
    rest = _.rest(aggregations);
    body[first.name] = first.aggregator();
    if (rest.length > 0) {
      body[first.name].aggs = buildAggregationBody(rest);
    }
    return body;
  };

  flattenAggregationResults = function(aggregations, results, parentData) {
    var aggregation, bucket, buckets, child, childAggregations, children, data, obj, value, _i, _j, _len, _len1;
    parentData = parentData || new Object;
    aggregation = _.first(aggregations);
    childAggregations = _.rest(aggregations);
    buckets = results[aggregation.name].buckets;
    data = [];
    for (_i = 0, _len = buckets.length; _i < _len; _i++) {
      bucket = buckets[_i];
      obj = _.clone(parentData);
      value = aggregation.bucketKey(bucket);
      obj[aggregation.name] = value;
      if (childAggregations.length === 0) {
        obj.count = aggregation.bucketCount(bucket);
        data.push(obj);
      } else {
        children = flattenAggregationResults(childAggregations, bucket, obj);
        for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
          child = children[_j];
          data.push(child);
        }
      }
    }
    return data;
  };

  window.myController = function($scope) {
    var $pb, aggregationBody, aggregations, dateAgg, dateFormat, days, es;
    $pb = $('.progress-bar');
    window.setProgressBarStatus = function(percentage) {
      $pb.css('width', "" + percentage + "%");
      $pb.attr('aria-valuenow', percentage);
      return $pb.html("" + percentage + "%");
    };
    setProgressBarStatus(0);
    days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    $scope.resetAll = function() {
      dc.filterAll();
      return dc.redrawAll();
    };
    dateFormat = d3.time.format("%A %B %e, %Y");
    dateAgg = new DateHistogramAggregation({
      name: 'date_of_trip',
      field: 'start_time',
      interval: '1h',
      dimensionFunction: function(d) {
        return d3.time.day.floor(d.date_of_trip);
      },
      chartPostSetup: function(c) {
        return c.group($scope.date_of_trip_group, "Rides per Day");
      },
      chartOptions: {
        title: function(d) {
          return "" + (dateFormat(d.key)) + "\n" + d.value + " rides";
        }
      }
    });
    aggregations = [
      dateAgg, new TermsAggregation({
        name: 'rider_type',
        field: 'user_type'
      }), new TermsAggregation({
        name: 'gender',
        field: 'gender',
        reduceSumFunction: function(d) {
          if (d.gender === 'Undisclosed' || d.rider_type === 'Customer') {
            return 0;
          } else {
            return d.count;
          }
        }
      }), new HistogramAggregation({
        name: 'trip_duration',
        field: 'trip_duration',
        interval: 60,
        dimensionFunction: function(d) {
          return d3.round(d.trip_duration) / 60;
        }
      })
    ];
    window.updateTimeout = null;
    window.updateProgressBarLinearly = function(min, max) {
      var updateTimeout, v;
      clearTimeout(updateTimeout);
      v = Number.parseInt($pb.attr('aria-valuenow'));
      if (v < max) {
        setProgressBarStatus(v + 3);
        return updateTimeout = setTimeout(_.partial(updateProgressBarLinearly, min, max), 100);
      }
    };
    es = new elasticsearch.Client({
      host: 'esdemo.local:9200',
      log: 'debug'
    });
    aggregationBody = buildAggregationBody(aggregations);
    updateProgressBarLinearly(0, 100);
    return es.search({
      index: 'divvy',
      body: {
        aggs: aggregationBody
      }
    }).then(function(resp) {
      clearTimeout(updateTimeout);
      setProgressBarStatus(100);
      $('#loading h4').html("Processing data...");
      return setTimeout(function() {
        var agg, data, _i, _len;
        data = flattenAggregationResults(aggregations, resp.aggregations);
        window.ndx = crossfilter(data);
        for (_i = 0, _len = aggregations.length; _i < _len; _i++) {
          agg = aggregations[_i];
          agg.applyToCrossfilter(ndx);
          $scope["" + agg.name + "_dimension"] = agg.dimension;
          $scope["" + agg.name + "_group"] = agg.group;
          $scope["" + agg.name + "_chart_post_setup"] = agg.chartPostSetup;
          $scope["" + agg.name + "_chart_options"] = agg.chartOptions;
          $scope["" + agg.name + "_ordering"] = agg.ordering;
        }
        $scope.day_of_week_dimension = ndx.dimension(function(d) {
          return d.date_of_trip.getDay();
        });
        $scope.day_of_week_group = $scope.day_of_week_dimension.group().reduceSum(dateAgg.reduceSumFunction);
        $scope.day_of_week_post_setup = function(c) {
          return c.label(function(d) {
            return days[d.key];
          }).xAxis().ticks(4);
        };
        $scope.hour_of_day_dimension = ndx.dimension(function(d) {
          return d.date_of_trip.getHours();
        });
        $scope.hour_of_day_group = $scope.hour_of_day_dimension.group().reduceSum(dateAgg.reduceSumFunction);
        $scope.hour_of_day_post_setup = function(c) {
          return c.xAxis().tickFormat(function(v) {
            if (v === 0) {
              return "Midnight";
            } else if (v < 12) {
              return "" + v + "am";
            } else {
              return "" + (v - 12) + "pm";
            }
          }).ticks(6);
        };
        $scope.$apply();
        $('#loading').css('display', 'none');
        return $('#charts').css('display', 'table');
      }, 200);
    });
  };

}).call(this);
