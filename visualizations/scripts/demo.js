// Generated by CoffeeScript 1.7.1
(function() {
  var Aggregation, DateHistogramAggregation, HistogramAggregation, TermsAggregation, buildAggregationBody, flattenAggregationResults,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Aggregation = (function() {
    Aggregation.prototype.dimension = null;

    Aggregation.prototype.group = null;

    function Aggregation(opts) {
      this.reduceSumFunction = __bind(this.reduceSumFunction, this);
      this.dimensionFunction = __bind(this.dimensionFunction, this);
      _.assign(this, opts);
      if (!this.name) {
        throw new Error('Name is not defined');
      }
    }

    Aggregation.prototype.chartPostSetup = function() {};

    Aggregation.prototype.bucketKey = function(bucket) {
      return bucket.key;
    };

    Aggregation.prototype.bucketCount = function(bucket) {
      return bucket.doc_count;
    };

    Aggregation.prototype.mapBucket = function(bucket) {
      return {
        key: this.bucketKey(bucket),
        count: this.bucketCount(bucket)
      };
    };

    Aggregation.prototype.dimensionFunction = function(d) {
      return d[this.name];
    };

    Aggregation.prototype.reduceSumFunction = function(d) {
      return d.count;
    };

    Aggregation.prototype.applyToCrossfilter = function(ndx) {
      this.dimension = ndx.dimension(this.dimensionFunction);
      return this.group = this.dimension.group().reduceSum(this.reduceSumFunction);
    };

    return Aggregation;

  })();

  DateHistogramAggregation = (function(_super) {
    __extends(DateHistogramAggregation, _super);

    function DateHistogramAggregation(opts) {
      DateHistogramAggregation.__super__.constructor.call(this, opts);
      this.interval = this.interval || 'day';
      if (!this.field) {
        throw new Error("Date histogram field for '" + this.name + "' is not defined");
      }
    }

    DateHistogramAggregation.prototype.aggregator = function() {
      return {
        date_histogram: {
          field: this.field,
          interval: this.interval
        }
      };
    };

    DateHistogramAggregation.prototype.bucketKey = function(bucket) {
      return new Date(bucket.key_as_string);
    };

    return DateHistogramAggregation;

  })(Aggregation);

  HistogramAggregation = (function(_super) {
    __extends(HistogramAggregation, _super);

    function HistogramAggregation(opts) {
      HistogramAggregation.__super__.constructor.call(this, opts);
      this.interval = this.interval || 1;
      if (!this.field) {
        throw new Error("Histogram field for '" + this.name + "' is not defined");
      }
    }

    HistogramAggregation.prototype.aggregator = function() {
      return {
        histogram: {
          field: this.field,
          interval: this.interval
        }
      };
    };

    return HistogramAggregation;

  })(Aggregation);

  TermsAggregation = (function(_super) {
    __extends(TermsAggregation, _super);

    function TermsAggregation(opts) {
      TermsAggregation.__super__.constructor.call(this, opts);
      if (!this.field) {
        throw new Error("Terms field for '" + this.name + "' is not defined");
      }
    }

    TermsAggregation.prototype.aggregator = function() {
      return {
        terms: {
          field: this.field
        }
      };
    };

    return TermsAggregation;

  })(Aggregation);

  window.angular.module('app', ['angularDc']);

  buildAggregationBody = function(aggregations) {
    var body, first, rest;
    body = {};
    first = _.first(aggregations);
    rest = _.rest(aggregations);
    body[first.name] = first.aggregator();
    if (rest.length > 0) {
      body[first.name].aggs = buildAggregationBody(rest);
    }
    return body;
  };

  flattenAggregationResults = function(aggregations, results, parentData) {
    var aggregation, bucket, buckets, child, childAggregations, children, data, obj, _i, _j, _len, _len1;
    parentData = parentData || new Object;
    aggregation = _.first(aggregations);
    childAggregations = _.rest(aggregations);
    buckets = results[aggregation.name].buckets;
    data = [];
    for (_i = 0, _len = buckets.length; _i < _len; _i++) {
      bucket = buckets[_i];
      obj = _.clone(parentData);
      obj[aggregation.name] = aggregation.bucketKey(bucket);
      if (childAggregations.length === 0) {
        obj.count = aggregation.bucketCount(bucket);
        data.push(obj);
      } else {
        children = flattenAggregationResults(childAggregations, bucket, obj);
        for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
          child = children[_j];
          data.push(child);
        }
      }
    }
    return data;
  };

  window.myController = function($scope) {
    var aggregations, es;
    $scope.resetAll = function() {
      dc.filterAll();
      return dc.redrawAll();
    };
    aggregations = [
      new TermsAggregation({
        name: 'gender',
        field: 'gender'
      }), new DateHistogramAggregation({
        name: 'date_of_trip',
        field: 'start_time'
      }), new HistogramAggregation({
        name: 'age',
        field: 'age'
      }), new HistogramAggregation({
        name: 'trip_duration',
        field: 'trip_duration',
        interval: 60,
        dimensionFunction: function(d) {
          return d3.round(d.trip_duration) / 60;
        }
      })
    ];
    es = new elasticsearch.Client({
      host: 'esdemo.local:9200',
      log: 'debug'
    });
    return es.search({
      index: 'divvy',
      body: {
        aggs: buildAggregationBody(aggregations)
      }
    }).then(function(resp) {
      var agg, data, _i, _len;
      data = flattenAggregationResults(aggregations, resp.aggregations);
      window.ndx = crossfilter(data);
      for (_i = 0, _len = aggregations.length; _i < _len; _i++) {
        agg = aggregations[_i];
        agg.applyToCrossfilter(ndx);
        $scope["" + agg.name + "_dimension"] = agg.dimension;
        $scope["" + agg.name + "_group"] = agg.group;
        $scope["" + agg.name + "_chart_post_setup"] = agg.chartPostSetup;
      }
      return $scope.$apply();
    });
  };

}).call(this);
